---
title: Многофункции
---

{% include menu.html %}

Raku реализует _множественную диспетчеризацию_ на основе сигнатуры функции. Это позволяет создавать функции, которые имеют одно и то же имя, но принимают разные типы входных данных. Используйте декларатив `multi` для каждой из вариантов функции.

```raku
multi sub add(Int $x, Int $y) { $x + $y }
multi sub add(Str $x, Str $y) { $x ~ $y }
```

(Можно опустить `sub` после `multi`.)

Если у вас есть два варианта одной и той же функции, компилятор выполняет множественную диспетчеризацию в зависимости от того, какие аргументы он видит в вызове функции. Сравните следующие два вызова:

```raku
say add(10, 20); # 30
say add('10', '20'); # 1020
```

Первый вызов запускает функцию с целочисленными параметрами, в то время как второй вызов запускает второй вариант функции, который ожидает две строки.

## Литеральные параметры

Интересный случай для многофункций — это наличие вариантов, которые имеют литеральные значения в качестве параметров. Рассмотрим следующие два варианта:

```raku
multi sub f(42) {say 'Это ответ'}
multi sub f($x) {say "$x не является ответом"}
```

Первый вариант выполняется только тогда, когда вы вызываете функцию с точным значением 42. В других случаях используется второй вариант. Порядок, в котором эти функции определены, не имеет значения.

```raku
f(10); # 10 не является ответом
f(42); # Это ответ
```

{% include nav.html %}